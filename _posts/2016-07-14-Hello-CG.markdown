---
layout:     post
title: 计算机图形学概论-Introduction to Computer Graphic
subtitle:   " \"Hello World, Hello CG\""
date:       2016-07-14 08:00:00
author:     "PlayYan"
header-img: "img/post-bg-2015.jpg"
tags: Computer Graphic
grammar_cjkRuby: true
---

> "Yeah It's on."

## 概述
计算机图形学(Computer Graphics，简称CG)是利用计算机技术创建和处理图像的理论、方法和技术。
具体地说，是一种使用数学算法将二维或三维图形转化为计算机显示器的栅格形式的科学（所谓的光栅化，rasterize）。简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。
图形学已在多种领域频繁应用，尤其是游戏开发领域。
    
## 渲染方程

渲染方程从物理光学出发，描述了光在空间、场景中的传播特性。方程在理论上给出了光线传播的完美数值计算结果。
![enter description here][1]


L_o是在特定位置x及角度w的出射光。
L_e是在同一位置x及角度w的入射光。
d w_i 积分部分，是入射方向半球体的无穷累加。
f_r 是在该点从入射方向到出射方向光的反射比例。
L_i是该点的入射光位置及方向w'。
w_i * n是入射角带来的入射光衰减。
![enter description here][2]
但现阶段无法对渲染方程做到实时精确解。无论是离线渲染还是实时渲染，本质上是对渲染方程的不同逼近、拟合。
在离线渲染中，渲染质量为主要考虑因素，可以牺牲时间。于是在积分计算处尽可能拟合，但无法得到物理上完全精确的数值解。
在实时渲染中，实时交互是主要因素，需保证30-60帧率，所以牺牲画面质量，将积分项拆为若干因子的求和，并辅以各种cheat把戏。cheat在实时渲染中应用广泛，意即某项算法本质不完全是基于物理的渲染（Physically Based Rending），而是伪造出一种画面效果，但能符合大多数人的视觉感受，使人觉得画面质量较佳。例如火焰燃烧、视差贴图。

## 实时渲染-可编程渲染管线
在现阶段的各平台游戏设备（PC、主机、移动设备），3D图形渲染流程大致都符合下图，此流水线即为可编程渲染管线。每批次的渲染图元，一般为三角面。近几年也发展出了新的体素渲染（voxel rendering），渲染图元是单个体素，可以理解为很微小的单个立方体。
![enter description here][3]
介绍主要阶段：

 1. Input-Assembler Stage 
图元装配阶段。向渲染管线输入模型数据（顶点、顶点法线、平面、顶点纹理坐标、材质属性等等）。
现阶段游戏的场景、物体、人物，都由软件3D建模生成。模型数据可见示例。
 2. Vertex-Shader Stage
顶点着色器阶段。此阶段的输入一般即是单个顶点（但其实实际上会并行处理多个顶点），处理其上的顶点数据，如对顶点施以模型空间->世界空间->观察空间的矩阵变换、每顶点光照、纹理计算、为动画角色蒙皮等。输出是完成变换、光照后的顶点，其位置及顶点法线已变换到齐次裁剪空间。
在实际应用中，顶点着色器与之后阶段的几何着色器、像素着色器是完全可编程的。着色器编程语言在OpenGl下为GLSL（GL Shader Language）语言,DirectX下为（High Level Shader Language）语言，语法类似C语言，但特性精简许多。
 3. Geometry-Shader Stage
几何着色器阶段。此阶段完全可编程。处理已经在齐次裁剪空间的单个图元。它能剔除或修改输入的图元，也能生成新的图元。典型应用有阴影体积拉伸、立方体贴图渲染、动态镶嵌、布料模拟等。
 4. Stream-Output Stage
流输出。
现在的GPU允许把送至此阶段的数据重新写回内存，回到管线之始做进一步处理，即为流输出。经由流输出，许多精美效果可不经CPU实现，如头发渲染。
 5. Rasterizer Stage
光栅化阶段。渲染管线中极为重要的部分。职责包括裁剪、屏幕映射、预深度测试等。
主要说明：
裁剪：此时图元已被变换至齐次裁剪空间，但在视景体中，可能有多个三角面横跨视景体边界。所以要将视景体外的顶点、平面等裁去，并依裁剪生成新的顶点或平面。联想如切西瓜。
（非常重要）屏幕映射：完成裁剪后的图元，映射变换至屏幕空间，并插值计算图元范围内的像素的各个属性（纹理坐标、法线、材质等）。插值后，组织好数据结构，以便下阶段像素着色器处理。这一步即真正意义上的“光栅化”。
 6. Pixel-Shader Stage
像素着色器阶段，完全可编程。输入上单个像素的一组属性（由光栅化阶段插值而得），输出是单个像素的一个颜色矢量，代表像素的颜色值。
职责是替每个像素上色（即光照、其他处理）。像素着色器也会丢弃一些像素，如某些像素被判断为透明的。着色（上色）计算过程，是由接收到的纹理坐标去采样对应纹理图片上的像素、计算每像素光照，以及任何会影响像素颜色的计算。
 7. Output-Merger Stage 
输出合并阶段。进行多个测试，包括深度测试、模板测试、alpha测试。若像素通过所有测试，则将其颜色矢量与帧缓冲的源色进行混合，混合方式由alpha混合函数定义（由目标颜色、源颜色加权确定，函数中的因子可依需要自由定义）。

## 离线渲染
基本算法有光线跟踪、辐射度模型等。以下介绍光线跟踪算法。
基本光线跟踪算法原理：
![enter description here][4]
如图所示，为算法建立一个投影参考点在z轴、屏幕空间在xy平面的坐标系统。由于从光源发出的光线有无穷多条，使得直接从光源出发对光线进行跟踪变得非常困难。然而实际上，从光源发出的光线只有少数经由场景的反射和透射（折射）后到达观察者眼中。因此，基本光线跟踪算法采用逆向跟踪光路的做法，完成整个场景的绘制。 
光线跟踪思路：
从视点出发，通过图像平面上每个像素中心向场景发出一条光线，光线的起点为视点，方向为像素中心和视点连线单位向量。按基本Phong光照模型，光线与离视点最近的场景物体表面交点有三种可能：

 - 当前交点所在的物体表面为理想漫射面，跟踪结束。
 - 当前交点所在的物体表面为理想镜面，光线沿其镜面反射方向（实际光路即为入射方向）继续跟踪。
 - 当前交点所在的物体表面为理想透射面，光线沿其透射方向继续跟踪。


反射和折射光线统称为从属光线（secondary ray），对每一条从属光线重复以上三条处理过程：光线从先前交点出发，与最近的场景物体表面相交，然后递归地生成下一条折射和反射光线。每像素出发的光线在场景中不停被反射和折射时，逐个将相交表面加入到一个二叉光线跟踪树（ray-tracing tree）中，树的左分支可表示为反射光线，右分支表示投射光线。
对于屏幕空间任一像素点，当以下任意条件满足，该像素光线就停止跟踪：

 - 该光线最终与理想漫反射面相交。
 - 该光线与场景中一个光源相交且该光源不是一个反射面。
 - 二叉树达到最大允许深度。

在每一个表面交点，引入基本Phong光照模型来确定表面光照强度贡献。反射光线由反射定律确定，折射光线由斯涅耳定律确定，由反射光线、折射光线，套公式即可计算出该交点强度值，并将其存放在二叉树的表面节点位置。而那些与非反射面光源相交的光线，可直接由光源对其强度赋值。
在停止光线跟踪时，意味着整个二叉树也建立完毕。从树的末端终结节点开始累计光照强度贡献。且树的每一节点的表面强度因离开父节点（相邻的上一节点）表面的举例而衰减，并加入到父节点表面的强度中。以上的累加、衰减计算完毕后，最终得到二叉树根节点的光照强度，即是此单个像素的强度。若某一像素光线与场景中任一对象均不相交，则其二叉树为空且用背景光强度对其赋值。

## 困境
光线跟踪有约95%的性能开销，用于像素光线与物体的求交运算。设想屏幕空间分辨率为800x800，则初始像素光线共64万条；开始跟踪后，光线在场景中不断的反射、折射，且每次都生成新的从属光线，从属光线再继续反射折射，递归直至跟踪结束。故所需计算的交点数量极大，且每次求交运算，都至少有1次浮点数乘法、1次浮点数开方运算。总的运算量极为惊人。
改进
简化场景，使用球体。与球体求交，运算量显著降低。
使用多种方法简化场景，从而避免光线与不可见物体的求交（由于不可见，所以对成像无影响）。如对物体使用包围盒等（进一步，用包围盒包围更多的包围体，从外向内使用求交测试，一旦与某层包围体无交点，则对内层物体对象不进行求交运算）
空间分割，将场景包含进一个立方体，然后将立方体逐次分割，类似n阶魔方。直至最小子立方体所包含的物体表面数目达到预设的最大值。如预设最小子立方体至多包含一个表面。然后在光线跟踪时仅对包含表面的立方体求交。此方法对简单场景有极高性能，但若场景复杂后，性能也会下降。

## 彩蛋
博主头像图片就是由简单的光线追踪渲染器渲染而得，场景是Cornell Box。以本博文作为写博开篇吧。CG领域有诸多有意思的课题，博主实力并不强，仍需学习提高，与诸位共勉。Enjoy Computer Graphic！

  [1]: ./img/2016-0714-Hello-CG/render%20equation.png "render equation.png"
  [2]: ./img/2016-0714-Hello-CG/image.png "image.png"
  [3]: ./img/2016-0714-Hello-CG/pipelien.png "pipelien.png"
  [4]: ./img/2016-0714-Hello-CG/ray%20tracing.png "ray tracing.png"